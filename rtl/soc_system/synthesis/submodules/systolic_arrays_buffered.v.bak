`timescale 1 ps / 1 ps
module systolic_array_top (
        input  wire [7:0]   csr_address,            //        csr.address
        input  wire         csr_write,              //           .write
        input  wire [31:0]  csr_writedata,          //           .writedata
        output wire [31:0]  csr_readdata,           //           .readdata
        input  wire         csr_read,               //           .read
        input  wire [255:0] data_in_data,           //    data_in.data
        output wire         data_in_ready,          //           .ready
        input  wire         data_in_valid,          //           .valid
        output wire [255:0] data_out_data,          //   data_out.data
        input  wire         data_out_ready,         //           .ready
        output wire         data_out_valid,         //           .valid
        output wire         data_out_startofpacket, //           .startofpacket
        output wire         data_out_endofpacket,   //           .endofpacket
        input  wire         reset_sink_reset,       // reset_sink.reset
        input  wire         clock_sink              // clock_sink.clk
    );

    // TODO: Auto-generated HDL template

    assign csr_readdata = 32'b00000000000000000000000000000000;

    assign data_in_ready = 1'b0;

    assign data_out_valid = 1'b0;

    assign data_out_data = 256'b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;

    assign data_out_startofpacket = 1'b0;

    assign data_out_endofpacket = 1'b0;

endmodule

module systolic_16x16_buffered(
	input CLOCK,
	input reset,
	input input_valid,
	input backpressure,
	
	input [127:0] in_col,
	input [127:0] in_row,
	input [127:0] in_data,
	
	output [127:0] out_col,
	output [127:0] out_row,
	output [127:0] out_data
);
	wire [127:0] delay_row;
	wire [127:0] delay_col;
	
	assign delay_col[7:0] = in_col[7:0];
	assign delay_row[7:0] = in_row[7:0];
	genvar i;
	generate
		for (i = 1; i < 16; i = i + 1) begin: delay_data
			wide_delay #(i) d_col(
				.CLOCK(CLOCK),
				.en(input_valid && !backpressure),
				.reset(reset),
				.in(in_col[(i+1)*8-1:i*8]),
				.out(delay_col[(i+1)*8-1:i*8])
			);
			wide_delay #(i) d_row(
				.CLOCK(CLOCK),
				.en(input_valid && !backpressure),
				.reset(reset),
				.in(in_row[i*8-1:i*8]),
				.out(delay_row[i*8-1:i*8])
			);
		end
	endgenerate
	
	systolic_16x16 sys_mod0(
		.CLOCK(CLOCK),
		.input_valid(input_valid && !backpressure),
		.reset(reset),
		.mult_over(0),
	
		.in_col(delay_col),
		.in_row(delay_row),
		.in_data(0),
		
		.out_data(out_data)
	);
	
	
endmodule

module wide_delay
#(
	parameter DEPTH = 1,
	parameter DATA_WIDTH = 8
)
(
	input CLOCK,
	input en,
	input reset,

	input [DATA_WIDTH-1:0] in,
	output [DATA_WIDTH-1:0] out
);
	
	reg [DATA_WIDTH-1:0] delay [DEPTH-1:0];
	assign out = delay[DEPTH-1];
	
	integer idx;
	generate
	always @ (posedge CLOCK, posedge reset) begin
		if (reset) begin
			for (idx = 0; idx < DEPTH; idx = idx + 1) begin
				delay[idx] <= 0;
			end
		end
		else if (en) begin
			delay[0] <= in;
			for (idx = 1; idx < DEPTH; idx = idx + 1) begin : delay_line
				delay[idx] <= delay[idx-1];
			end
		end
	end
	endgenerate

endmodule
